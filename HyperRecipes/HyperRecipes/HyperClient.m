//
//  HyperClient.m
//  HyperRecipes
//
//  Created by Attila BÃ¡rdos on 1/25/14.
//  Copyright (c) 2014 Delta Velorum Kft. All rights reserved.
//

#import "HyperClient.h"
#import <AFNetworking.h>
#import "Utils.h"
#import "Recipe.h"
#import "AppDelegate.h"
#import "Recipe+Helper.h"

@interface HyperClient ()
@property (strong, nonatomic) AFHTTPRequestOperationManager *manager;
@end

@implementation HyperClient

+ (HyperClient*)sharedInstance {
    static HyperClient *sharedInstance = nil;
    if (sharedInstance == nil) {
        sharedInstance = [[HyperClient alloc] init];
        sharedInstance.manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:[NSURL URLWithString:@"http://hyper-recipes.herokuapp.com"]];
        sharedInstance.manager.requestSerializer = [AFJSONRequestSerializer serializerWithWritingOptions:0];
    }
    return sharedInstance;
}

- (void)syncWithCompletionHandler:(void (^)(NSError *error))completion {
    // create a separate context to avoid Core Data problems running in the background
    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init];
    context.persistentStoreCoordinator = ((AppDelegate*)[UIApplication sharedApplication].delegate).managedObjectContext.persistentStoreCoordinator;

    // register for notifications generated by the new context
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundThreadDidSave:) name:NSManagedObjectContextDidSaveNotification object:context];

    // download recipes from the server
    [self.manager GET:@"/recipes" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        DLog(@"%@ response:\n%@", operation.request.URL, responseObject);

        // make sure that response is an array
        if ([responseObject isKindOfClass:[NSArray class]] == NO) {
            NSError *error = [NSError errorWithDomain:@"HyperRecipes" code:-1 userInfo:@{NSLocalizedDescriptionKey: [NSString stringWithFormat:@"response is not an array (%@)", operation.request.URL]}];
            DLog(@"** error: %@", [error localizedDescription]);
            if (completion) {
                completion(error);
                return;
            }
        }
        
        // process response (create new Recipe objects or update existing ones)
        // for the sake of simplicity there is no conflict resolution: if the same recipe
        // has been modified both on the server and locally since the last sync, the
        // server will always win (so local changes will be lost)
        [self processRecipesFromServer:responseObject inContext:context];
        
        // upload recipes which hasn't been uploaded yet
        NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Recipe"];
        request.predicate = [NSPredicate predicateWithFormat:@"serverId == 0"];
        NSArray *recipesToBeUploaded = [context executeFetchRequest:request error:nil];
        if (recipesToBeUploaded.count > 0) {
            [self uploadRecipes:recipesToBeUploaded inContext:context];
        }
        
        // completed without problems
        if (completion) {
            completion(nil);
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        DLog(@"** error: %@ (%@)", [error localizedDescription], operation.request.URL);
        if (completion) {
            completion(error);
        }
    }];
}

- (void)processRecipesFromServer:(NSArray*)recipes inContext:(NSManagedObjectContext*)context {
    // process the array
    for (NSDictionary *r in recipes) {
        // make sure it's a dictionary
        if ([r isKindOfClass:[NSDictionary class]] == NO) {
            DLog(@"** error: array elem is not a dictionary");
            continue;
        }
        
        // find out if it's a new or an existing recipe
        Recipe *recipe = nil;
        NSInteger serverId = [r[@"id"] integerValue];
        NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:@"Recipe"];
        request.predicate = [NSPredicate predicateWithFormat:@"serverId == %d", serverId];
        NSArray *result = [context executeFetchRequest:request error:nil];
        if (result.count > 0) {
            recipe = [result firstObject];
            recipe.dirty = @NO;     // server always wins (ovewrites local changes)
            DLog(@"updating existing recipe (%@)", recipe.name);
        } else {
            recipe = [Recipe recipeInContext:context];
            recipe.serverId = r[@"id"];
            DLog(@"downloading new recipe (%@)", r[@"name"]);
        }

        // update recipe's attributes
        recipe.name = r[@"name"];
        recipe.difficulty = [NSNumber numberWithInteger:[r[@"difficulty"] integerValue]];
        recipe.desc = [self stringFromObject:r[@"description"]];
        recipe.instructions = [self stringFromObject:r[@"instructions"]];
        recipe.favorite = [self numberFromObject:r[@"favorite"]];
        recipe.imageUrl = [self stringFromObject:r[@"photo"][@"url"]];
        recipe.updatedAt = r[@"updated_at"];
    }
    [context save:nil];
}

- (void)uploadRecipes:(NSArray*)recipes inContext:(NSManagedObjectContext*)context {
    for (Recipe *r in recipes) {
        NSDictionary *params = @{@"recipe": @{@"name": r.name, @"difficulty": r.difficulty}};
        [self.manager POST:@"/recipes" parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
            DLog(@"%@ response:\n%@", operation.request.URL, responseObject);
            // make sure it's a dictionary
            if ([responseObject isKindOfClass:[NSDictionary class]] == NO) {
                DLog(@"** error: array elem is not a dictionary");
            } else {
                NSDictionary *dict = (NSDictionary*)responseObject;
                r.serverId = dict[@"id"];
                DLog(@"recipe uploaded: %@", r);
            }
        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
            DLog(@"** error: %@ (%@), HTTPBody = %@", [error localizedDescription], operation.request.URL, [[NSString alloc] initWithData:operation.request.HTTPBody encoding:NSUTF8StringEncoding]);
        }];
#if 0
        [self.manager POST:@"/recipes" parameters:params constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
            [formData appendPartWithFormData:[NSJSONSerialization dataWithJSONObject:params options:0 error:nil] name:@"recipe"];
        } success:^(AFHTTPRequestOperation *operation, id responseObject) {
            DLog(@"%@ response:\n%@", operation.request.URL, responseObject);
            DLog(@"recipe uploaded: %@", r.name);
        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
            DLog(@"** error: %@ (%@)", [error localizedDescription], operation.request.URL);
        }];
#endif
    }
    [context save:nil];
}

#pragma mark - Managed object context sync

- (void)backgroundThreadDidSave:(NSNotification*)notification {
    // merge changes made in the background thread's context into main thread's context
    [((AppDelegate*)[UIApplication sharedApplication].delegate).managedObjectContext mergeChangesFromContextDidSaveNotification:notification];
}

#pragma mark - Other methods

- (NSString*)stringFromObject:(id)object {
    return ([object isKindOfClass:[NSString class]] ? (NSString*)object : @"");
}

- (NSNumber*)numberFromObject:(id)object {
    return ([object isKindOfClass:[NSNumber class]] ? (NSNumber*)object : @(0));
}

@end
