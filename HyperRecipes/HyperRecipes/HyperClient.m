//
//  HyperClient.m
//  HyperRecipes
//
//  Created by Attila BÃ¡rdos on 1/25/14.
//  Copyright (c) 2014 Delta Velorum Kft. All rights reserved.
//

#import "HyperClient.h"
#import <AFNetworking.h>
#import "Utils.h"
#import "Recipe.h"
#import "AppDelegate.h"
#import "Recipe+Helper.h"

@interface HyperClient ()
@property (strong, nonatomic) AFHTTPRequestOperationManager *manager;
@end

@implementation HyperClient

+ (HyperClient*)sharedInstance {
    static HyperClient *sharedInstance = nil;
    if (sharedInstance == nil) {
        sharedInstance = [[HyperClient alloc] init];
        sharedInstance.manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:[NSURL URLWithString:@"http://hyper-recipes.herokuapp.com"]];
        sharedInstance.manager.requestSerializer = [AFJSONRequestSerializer serializerWithWritingOptions:0];
        
        // notification
        [[NSNotificationCenter defaultCenter] addObserver:sharedInstance selector:@selector(recipeDidChange:) name:@"RecipeDidChange" object:nil];
    }
    return sharedInstance;
}

#pragma mark - Synchronization

- (void)syncWithCompletionHandler:(void (^)(NSError *error))completion {
    DLog(@"--- sync ---");

    // create a separate context to avoid Core Data problems caused by making changes in a background thread
    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init];
    context.persistentStoreCoordinator = ((AppDelegate*)[UIApplication sharedApplication].delegate).managedObjectContext.persistentStoreCoordinator;

    // register for notifications generated by the new context (so changes made to Core Data in the background will also be availale on the main thread's context)
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundThreadDidSave:) name:NSManagedObjectContextDidSaveNotification object:context];
    
    // get recipes from the server, then (when completed) create new recipes on the server, update recipes changed locally and delete recipes previously delete locally;
    // for the sake of simplicity there is no conflict resolution: if the same recipe exists both on the server and locally, then newer always wins (which is somewhat
    // unpredictable since it can't be guaranteed that clock are in sync)
    [self getRecipesInContext:context withCompletion:^(NSError *error) {
        // abort if 'get' has failed
        if (error) {
            DLog(@"** error: %@ (when downloading recipes)", [error localizedDescription]);
            if (completion) {
                completion(error);
            }
            return;
        }

        // create recipes which haven't been uploaded to the server yet
        NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Recipe"];
        request.predicate = [NSPredicate predicateWithFormat:@"serverId == 0"];
        NSArray *recipesToBeUploaded = [context executeFetchRequest:request error:nil];
        for (Recipe *recipe in recipesToBeUploaded) {
            [self createRecipe:recipe inContext:context withCompletion:^(NSManagedObjectContext *context, Recipe *recipe, NSNumber *serverId, NSString *imageUrl, NSError *error) {
                if (!error) {
                    // update recipe with serverID and imageUrl
                    recipe.serverId = serverId;
                    recipe.imageUrl = imageUrl;
                    recipe.dirty = @NO;
                    
                    // remove local image file if it has been successfully uploaded to the server
                    if (recipe.imageUrl.length > 0 && recipe.imageFileName.length > 0) {
                        [recipe removeImage];
                    }

                    // save changes
                    [context save:nil];
                    DLog(@"recipe created: %@", recipe.name);
                } else {
                    DLog(@"** error: %@ (when creating recipe: %@)", [error localizedDescription], recipe.name);
                }
            }];
        }
        
        // update recipes which have been changed locally, but haven't been updated to the server yet
        request.predicate = [NSPredicate predicateWithFormat:@"serverId != 0 && dirty == YES"];
        NSArray *recipesToBeUpdated = [context executeFetchRequest:request error:nil];
        for (Recipe *recipe in recipesToBeUpdated) {
            [self updateRecipe:recipe inContext:context withCompletion:^(NSManagedObjectContext *context, Recipe *recipe, NSError *error) {
                if (!error) {
                    // update recipe
                    recipe.dirty = @NO;
                    
                    // remove local image file assuming the image update was successful (it would be useful to have some feedback on this,
                    // though the server sends an empty response in this case)
                    if (recipe.imageUrl.length > 0 && recipe.imageFileName.length > 0) {
                        [recipe removeImage];
                    }
                    
                    // save changes
                    [context save:nil];
                    DLog(@"recipe updated: %@", recipe.name);
                } else {
                    DLog(@"** error: %@ (when updating recipe: %@)", [error localizedDescription], recipe.name);
                }
            }];
        }
        
        // delete recipes from server which have been locally deleted earlier
        request.predicate = [NSPredicate predicateWithFormat:@"deleted == YES"];
        NSArray *recipesToBeDeleted = [context executeFetchRequest:request error:nil];
        for (Recipe *recipe in recipesToBeDeleted) {
            if ([recipe.serverId integerValue] == 0) {
                // it hasn't been uploaded to the server yet, just remove it from Core Data
                [context deleteObject:recipe];
            } else {
                // remove it from the server first, then remove from Core Data if successful
                [self deleteRecipe:recipe inContext:context withCompletionHandler:^(NSManagedObjectContext *context, Recipe *recipe, NSError *error) {
                    if (!error) {
                        [context deleteObject:recipe];
                        [context save:nil];
                        DLog(@"recipe deleted: %@", recipe.name);
                    } else {
                        DLog(@"** error: %@ (when deleting recipe: %@)", [error localizedDescription], recipe.name);
                    }
                }];
            }
        }
        [context save:nil];
        
        // sync completed without (major) problems
        if (completion) {
            completion(nil);
        }
    }];
}

#pragma mark - Web service calls

- (void)getRecipesInContext:(NSManagedObjectContext*)context withCompletion:(void (^)(NSError *error))completion {
    [self.manager GET:@"/recipes" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        // quit if response is not an array
        if ([responseObject isKindOfClass:[NSArray class]] == NO) {
            DLog(@"** error: response is not an array (%@)", operation.request.URL);
            if (completion) {
                completion([NSError errorWithDomain:@"HyperRecipes" code:-2 userInfo:@{NSLocalizedDescriptionKey: [NSString stringWithFormat:@"response is not an array (%@)", operation.request.URL]}]);
            }
            return;
        }
        
        // fetch current set of recipes (where serverId != 0) and remove the ones (at the end) which aren't on the server's list (i.e. deleted by another client)
        NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:@"Recipe"];
        request.predicate = [NSPredicate predicateWithFormat:@"serverId != 0"];
        NSMutableSet *recipesToBeDeleted = [NSMutableSet setWithArray:[context executeFetchRequest:request error:nil]];
        
        // process the response array
        for (NSDictionary *recipeDict in (NSArray*)responseObject) {
            // unlikely, but better to be safe than to crash
            if ([recipeDict isKindOfClass:[NSDictionary class]] == NO) {
                continue;
            }

            // find out if it's a new or an existing recipe
            BOOL exisitingRecipe = NO;
            BOOL serverIsNewer = NO;
            Recipe *recipe = nil;
            NSInteger serverId = [recipeDict[@"id"] integerValue];
            NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:@"Recipe"];
            request.predicate = [NSPredicate predicateWithFormat:@"serverId == %d", serverId];
            NSArray *result = [context executeFetchRequest:request error:nil];
            if (result.count > 0) {
                // it's an existing recipe, find out if the server has a newer version
                recipe = [result firstObject];
                exisitingRecipe = YES;
                serverIsNewer = ([recipe.updatedAt compare:recipeDict[@"updated_at"]] == NSOrderedAscending);
                if (serverIsNewer) {
                    DLog(@"server -> local (%@, %@ < %@)", recipe.name, recipe.updatedAt, recipeDict[@"updated_at"]);
                }
                
                // remove the recipe from the "to be deleted" set
                [recipesToBeDeleted removeObject:recipe];
            } else {
                // it's a new recipe
                recipe = [Recipe recipeInContext:context];
                recipe.serverId = recipeDict[@"id"];
                DLog(@"downloading new recipe (%@)", recipeDict[@"name"]);
            }
            
            // set/overwrite recipe's attributes (if it's a new recipe or the server has a newer version)
            if (!exisitingRecipe || serverIsNewer) {
                recipe.name = recipeDict[@"name"];
                recipe.difficulty = [self numberFromObject:recipeDict[@"difficulty"]];
                recipe.desc = [self stringFromObject:recipeDict[@"description"]];
                recipe.instructions = [self stringFromObject:recipeDict[@"instructions"]];
                recipe.favorite = [self numberFromObject:recipeDict[@"favorite"]];
                recipe.imageUrl = [self stringFromObject:recipeDict[@"photo"][@"url"]];
                recipe.dirty = @NO;
                recipe.updatedAt = recipeDict[@"updated_at"];
            }
        }
        
        // remove recipes which weren't on the server's list and are from the server
        for (Recipe *r in recipesToBeDeleted) {
            DLog(@"recipe deleted: %@", r.name);
            [context deleteObject:r];
        }
        
        // save changes
        [context save:nil];
        if (completion) {
            completion(nil);
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        DLog(@"** error: %@ (%@)", [error localizedDescription], operation.request.URL);
        if (completion) {
            completion(error);
        }
    }];
}

- (void)createRecipe:(Recipe*)recipe inContext:(NSManagedObjectContext*)context withCompletion:(void (^)(NSManagedObjectContext *context, Recipe *recipe, NSNumber *serverId, NSString *imageUrl, NSError *error))completion {
    // collect parameters (and make sure strings aren't too long to avoid server issues)
    NSString *name = (recipe.name.length > 255 ? [recipe.name substringToIndex:255] : recipe.name);
    NSString *desc = (recipe.desc.length > 255 ? [recipe.desc substringToIndex:255] : recipe.desc);
    NSString *instructions = (recipe.instructions.length > 255 ? [recipe.instructions substringToIndex:255] : recipe.instructions);
    NSDictionary *params = @{@"recipe": @{@"name": name, @"difficulty": recipe.difficulty, @"description": desc, @"favorite": recipe.favorite, @"instructions": instructions}};

    // create and add operation to the queue
    [self.manager POST:@"recipes" parameters:params constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
        // append local image to the request
        if (recipe.imageFileName) {
            [formData appendPartWithFileData:recipe.imageData name:@"recipe[photo]" fileName:recipe.imageFileName mimeType:@"image/jpeg"];
        }
    } success:^(AFHTTPRequestOperation *operation, id responseObject) {
        if ([responseObject isKindOfClass:[NSDictionary class]]) {
            // extract and pass the server ID and the image URL to the completion handler
            NSDictionary *dict = (NSDictionary*)responseObject;
            NSNumber *serverId = dict[@"id"];
            NSString *imageUrl = [self stringFromObject:dict[@"photo"][@"url"]];
            if (completion) {
                completion(context, recipe, serverId, imageUrl, nil);
            }
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        DLog(@"** error: %@ (%@)", [error localizedDescription], operation.request.URL);
        if (completion) {
            completion(context, recipe, 0, nil, error);
        }
    }];
}

- (void)updateRecipe:(Recipe*)recipe inContext:(NSManagedObjectContext*)context withCompletion:(void (^)(NSManagedObjectContext *context, Recipe *recipe, NSError *error))completion {
    // collect parameters (and make sure strings aren't too long to avoid server issues)
    NSString *name = (recipe.name.length > 255 ? [recipe.name substringToIndex:255] : recipe.name);
    NSString *desc = (recipe.desc.length > 255 ? [recipe.desc substringToIndex:255] : recipe.desc);
    NSString *instructions = (recipe.instructions.length > 255 ? [recipe.instructions substringToIndex:255] : recipe.instructions);
    NSDictionary *params = @{@"recipe": @{@"name": name, @"difficulty": recipe.difficulty, @"description": desc, @"favorite": recipe.favorite, @"instructions": instructions}};

    // create and add PUT HTTP request operation to the queue
    // AFNetworking 2.1 doesn't seem to have a convenience method to create and run an AFHTTPRequestOperation which has a multipart PUT request
    // below code is a modified version fo AFNetworking's source code; it's a bit messy, but I couldn't find a better way
    NSString *URLString = [NSString stringWithFormat:@"/recipes/%d", [recipe.serverId integerValue]];
    NSMutableURLRequest *request = [self.manager.requestSerializer multipartFormRequestWithMethod:@"PUT" URLString:[[NSURL URLWithString:URLString relativeToURL:self.manager.baseURL] absoluteString] parameters:params constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
        // append local image to the request (if there is one)
        if (recipe.imageFileName) {
            [formData appendPartWithFileData:recipe.imageData name:@"recipe[photo]" fileName:recipe.imageFileName mimeType:@"image/jpeg"];
        }
    } error:nil];
    AFHTTPRequestOperation *operation = [self.manager HTTPRequestOperationWithRequest:request success:^(AFHTTPRequestOperation *operation, id responseObject) {
        if (completion) {
            completion(context, recipe, nil);
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        DLog(@"** error: %@ (%@)", [error localizedDescription], operation.request.URL);
        if (completion) {
            completion(context, recipe, error);
        }
    }];
    [self.manager.operationQueue addOperation:operation];
}

- (void)deleteRecipe:(Recipe*)recipe inContext:(NSManagedObjectContext*)context withCompletionHandler:(void (^)(NSManagedObjectContext *context, Recipe *recipe, NSError *error))completion {
    [self.manager DELETE:[NSString stringWithFormat:@"/recipes/%d", [recipe.serverId integerValue]] parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        if (completion) {
            completion(context, recipe, nil);
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        if (completion) {
            completion(context, recipe, error);
        }
    }];
}

#pragma mark - Managed object context sync

- (void)backgroundThreadDidSave:(NSNotification*)notification {
    // merge changes made in the background thread's context into main thread's context
    [((AppDelegate*)[UIApplication sharedApplication].delegate).managedObjectContext mergeChangesFromContextDidSaveNotification:notification];
}

#pragma mark - Notifications

- (void)recipeDidChange:(NSNotification*)notification {
    // run a silent sync when a recipe has changed to make sure all changes are saved to the server ASAP
    [self syncWithCompletionHandler:^(NSError *error) {
        if (error) {
            DLog(@"** error: %@ (when syncing silently)", [error localizedDescription]);
        }
    }];
}

#pragma mark - Other methods

- (NSString*)stringFromObject:(id)object {
    // the given object is either an NSNull object or an NSString; we need a valid string either way
    return ([object isKindOfClass:[NSString class]] ? (NSString*)object : @"");
}

- (NSNumber*)numberFromObject:(id)object {
    // the given object is either an NSNull object, a NSString or an NSNumber; we need a valid number either way
    return ([object isKindOfClass:[NSNumber class]] ? (NSNumber*)object : ([object isKindOfClass:[NSString class]] ? @([((NSString*)object) integerValue]) : @(0)));
}

@end
