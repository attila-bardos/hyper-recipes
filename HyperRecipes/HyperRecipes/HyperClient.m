//
//  HyperClient.m
//  HyperRecipes
//
//  Created by Attila BÃ¡rdos on 1/25/14.
//  Copyright (c) 2014 Delta Velorum Kft. All rights reserved.
//

#import "HyperClient.h"
#import <AFNetworking.h>
#import "Utils.h"
#import "Recipe.h"
#import "AppDelegate.h"

@interface HyperClient ()
@property (strong, nonatomic) AFHTTPRequestOperationManager *manager;
@end

@implementation HyperClient

+ (HyperClient*)sharedInstance {
    static HyperClient *sharedInstance = nil;
    if (sharedInstance == nil) {
        sharedInstance = [[HyperClient alloc] init];
        sharedInstance.manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:[NSURL URLWithString:@"http://hyper-recipes.herokuapp.com"]];
    }
    return sharedInstance;
}

- (void)sync {
    [self syncWithCompletionHandler:nil];
}

- (void)syncWithCompletionHandler:(void (^)(NSError *error))completion {
    // create a separate context to avoid Core Data problems running in the background
    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init];
    context.persistentStoreCoordinator = ((AppDelegate*)[UIApplication sharedApplication].delegate).managedObjectContext.persistentStoreCoordinator;

    // register for notifications generated by the new context
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundThreadDidSave:) name:NSManagedObjectContextDidSaveNotification object:context];

    // download recipes from the server
    [self.manager GET:@"/recipes" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        DLog(@"%@ response:\n%@", operation.request.URL, responseObject);

        // make sure that response is an array
        if ([responseObject isKindOfClass:[NSArray class]] == NO) {
            NSError *error = [NSError errorWithDomain:@"HyperRecipes" code:-1 userInfo:@{NSLocalizedDescriptionKey: [NSString stringWithFormat:@"response is not an array (%@)", operation.request.URL]}];
            DLog(@"** error: %@", [error localizedDescription]);
            if (completion) {
                completion(error);
                return;
            }
        }
        
        // process response (create new Recipe objects or update existing ones)
        // for the sake of simplicity there is no conflict resolution: if the same recipe
        // has been modified both on the server and locally since the last sync, the
        // server will always win (so local changes will be lost)
        [self processRecipesFromServer:responseObject inContext:context];
        
        // completed without problems
        if (completion) {
            completion(nil);
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        DLog(@"** error: %@ (%@)", [error localizedDescription], operation.request.URL);
        if (completion) {
            completion(error);
        }
    }];
}

- (void)processRecipesFromServer:(NSArray*)recipes inContext:(NSManagedObjectContext*)context {
    // process the array
    for (NSDictionary *r in recipes) {
        // make sure it's a dictionary
        if ([r isKindOfClass:[NSDictionary class]] == NO) {
            DLog(@"** error: array elem is not a dictionary");
            continue;
        }
        
        // find out if it's a new or an existing recipe
        Recipe *recipe = nil;
        NSInteger serverId = [r[@"id"] integerValue];
        NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:@"Recipe"];
        request.predicate = [NSPredicate predicateWithFormat:@"serverId == %d", serverId];
        NSArray *result = [context executeFetchRequest:request error:nil];
        if (result.count > 0) {
            recipe = [result firstObject];
            DLog(@"updating existing recipe (%@)", recipe.name);
        } else {
            recipe = [NSEntityDescription insertNewObjectForEntityForName:@"Recipe" inManagedObjectContext:context];
            DLog(@"downloading new recipe (%@)", r[@"name"]);
        }

        // update recipe's attributes
        recipe.serverId = r[@"id"];
        recipe.name = r[@"name"];
        recipe.difficulty = [NSNumber numberWithInteger:[r[@"difficulty"] integerValue]];
        recipe.desc = r[@"description"];
        recipe.instructions = r[@"instructions"];
        recipe.favorite = r[@"favorite"];
        recipe.imageUrl = r[@"photo"][@"url"];
        recipe.updatedAt = r[@"updated_at"];
        recipe.deleted = @NO;
        recipe.dirty = @NO;
    }
    [context save:nil];
}

#pragma mark - Managed object context sync

- (void)backgroundThreadDidSave:(NSNotification*)notification {
    // merge changes made in the background thread's context into main thread's context
    [((AppDelegate*)[UIApplication sharedApplication].delegate).managedObjectContext mergeChangesFromContextDidSaveNotification:notification];
}

@end
