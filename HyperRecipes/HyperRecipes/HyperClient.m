//
//  HyperClient.m
//  HyperRecipes
//
//  Created by Attila BÃ¡rdos on 1/25/14.
//  Copyright (c) 2014 Delta Velorum Kft. All rights reserved.
//

#import "HyperClient.h"
#import <AFNetworking.h>
#import "Utils.h"
#import "Recipe.h"
#import "AppDelegate.h"
#import "Recipe+Helper.h"

@interface HyperClient ()
@property (strong, nonatomic) AFHTTPRequestOperationManager *manager;
@end

@implementation HyperClient

+ (HyperClient*)sharedInstance {
    static HyperClient *sharedInstance = nil;
    if (sharedInstance == nil) {
        sharedInstance = [[HyperClient alloc] init];
        sharedInstance.manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:[NSURL URLWithString:@"http://hyper-recipes.herokuapp.com"]];
        sharedInstance.manager.requestSerializer = [AFJSONRequestSerializer serializerWithWritingOptions:0];
    }
    return sharedInstance;
}

#pragma mark - Synchronization

- (void)syncWithCompletionHandler:(void (^)(NSError *error))completion {
    DLog(@"--- sync ---");

    // create a separate context to avoid Core Data problems running in the background
    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init];
    context.persistentStoreCoordinator = ((AppDelegate*)[UIApplication sharedApplication].delegate).managedObjectContext.persistentStoreCoordinator;

    // register for notifications generated by the new context (so changes made to Core Data in
    // the background will also be availale on the main thread's context)
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundThreadDidSave:) name:NSManagedObjectContextDidSaveNotification object:context];
    
    // get recipes from the server, then (when completed) create new recipes on the server,
    // update recipes changed locally and delete recipes previously delete locally;
    // for the sake of simplicity there is no conflict resolution: if the same recipe exists both
    // on the server and locally, then newer always wins
    [self getRecipesInContext:context withCompletion:^(NSError *error) {
        // abort if 'get' has failed
        if (error) {
            DLog(@"** error: %@ (when downloading recipes)", [error localizedDescription]);
            if (completion) {
                completion(error);
            }
            return;
        }

        // create recipes which haven't been uploaded to the server yet
        NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@"Recipe"];
        request.predicate = [NSPredicate predicateWithFormat:@"serverId == 0"];
        NSArray *recipesToBeUploaded = [context executeFetchRequest:request error:nil];
        for (Recipe *recipe in recipesToBeUploaded) {
            [self createRecipe:recipe withCompletion:^(Recipe *recipe, NSNumber *serverId, NSString *imageUrl, NSError *error) {
                if (!error) {
                    recipe.serverId = serverId;
                    recipe.imageUrl = imageUrl;
                    recipe.dirty = @NO;
                    [context save:nil];
                    DLog(@"recipe created: %@", recipe.name);
                } else {
                    DLog(@"** error: %@ (when creating recipe: %@)", [error localizedDescription], recipe.name);
                }
            }];
        }
        
        // update recipes which have been changed locally, but haven't been updated to the server yet
        request.predicate = [NSPredicate predicateWithFormat:@"serverId != 0 && dirty == YES"];
        NSArray *recipesToBeUpdated = [context executeFetchRequest:request error:nil];
        for (Recipe *recipe in recipesToBeUpdated) {
            [self updateRecipe:recipe withCompletion:^(Recipe *recipe, NSError *error) {
                if (!error) {
                    recipe.dirty = @NO;
                    [context save:nil];
                    DLog(@"recipe updated: %@", recipe.name);
                } else {
                    DLog(@"** error: %@ (when updating recipe: %@)", [error localizedDescription], recipe.name);
                }
            }];
        }
        
        // delete recipes from server which have been locally deleted earlier
        request.predicate = [NSPredicate predicateWithFormat:@"deleted == YES"];
        NSArray *recipesToBeDeleted = [context executeFetchRequest:request error:nil];
        for (Recipe *recipe in recipesToBeDeleted) {
            if ([recipe.serverId integerValue] == 0) {
                // it hasn't been uploaded to the server yet, just remove it from Core Data
                [context deleteObject:recipe];
            } else {
                // remove it from the server first, then remove from Core Data if successful
                [self deleteRecipe:recipe withCompletionHandler:^(Recipe *recipe, NSError *error) {
                    if (!error) {
                        DLog(@"recipe deleted: %@", recipe.name);
                        [context deleteObject:recipe];
                        [context save:nil];
                    } else {
                        DLog(@"** error: %@ (when deleting recipe: %@)", [error localizedDescription], recipe.name);
                    }
                }];
            }
        }
        [context save:nil];
        
        // sync completed without (major) problems
        if (completion) {
            completion(nil);
        }
    }];
}

#pragma mark - Web service calls

- (void)getRecipesInContext:(NSManagedObjectContext*)context withCompletion:(void (^)(NSError *error))completion {
    [self.manager GET:@"/recipes" parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        // quit if response is not an array
        if ([responseObject isKindOfClass:[NSArray class]] == NO) {
            if (completion) {
                completion([NSError errorWithDomain:@"HyperRecipes" code:-2 userInfo:@{NSLocalizedDescriptionKey: [NSString stringWithFormat:@"response is not an array (%@)", operation.request.URL]}]);
            }
            return;
        }
        
        // process the response array
        for (NSDictionary *recipeDict in (NSArray*)responseObject) {
            if ([recipeDict isKindOfClass:[NSDictionary class]] == NO) {
                continue;
            }

            // find out if it's a new or an existing recipe
            BOOL exisitingRecipe = NO;
            BOOL serverIsNewer = NO;
            Recipe *recipe = nil;
            NSInteger serverId = [recipeDict[@"id"] integerValue];
            NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:@"Recipe"];
            request.predicate = [NSPredicate predicateWithFormat:@"serverId == %d", serverId];
            NSArray *result = [context executeFetchRequest:request error:nil];
            if (result.count > 0) {
                recipe = [result firstObject];
                exisitingRecipe = YES;
                serverIsNewer = ([recipe.updatedAt compare:recipeDict[@"updated_at"]] == NSOrderedAscending);
                if (serverIsNewer) {
                    DLog(@"server -> local (%@, %@ < %@)", recipe.name, recipe.updatedAt, recipeDict[@"updated_at"]);
                }
            } else {
                recipe = [Recipe recipeInContext:context];
                recipe.serverId = recipeDict[@"id"];
                DLog(@"downloading new recipe (%@)", recipeDict[@"name"]);
            }
            
            // set/overwrite recipe's attributes (if recipe hasn't been downloaded or server has a newer version)
            if (!exisitingRecipe || serverIsNewer) {
                recipe.name = recipeDict[@"name"];
                recipe.difficulty = [self numberFromObject:recipeDict[@"difficulty"]];
                recipe.desc = [self stringFromObject:recipeDict[@"description"]];
                recipe.instructions = [self stringFromObject:recipeDict[@"instructions"]];
                recipe.favorite = [self numberFromObject:recipeDict[@"favorite"]];
                recipe.imageUrl = [self stringFromObject:recipeDict[@"photo"][@"url"]];
                recipe.dirty = @NO;
                recipe.updatedAt = recipeDict[@"updated_at"];
            }
        }
        [context save:nil];
        if (completion) {
            completion(nil);
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        DLog(@"** error: %@ (%@)", [error localizedDescription], operation.request.URL);
        if (completion) {
            completion(error);
        }
    }];
}

- (void)createRecipe:(Recipe*)recipe withCompletion:(void (^)(Recipe *recipe, NSNumber *serverId, NSString *imageUrl, NSError *error))completion {
    NSDictionary *params = @{@"recipe": @{@"name": recipe.name, @"difficulty": recipe.difficulty}};
    [self.manager POST:@"/recipes" parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
        if ([responseObject isKindOfClass:[NSDictionary class]]) {
            NSDictionary *dict = (NSDictionary*)responseObject;
            NSNumber *serverId = dict[@"id"];
            NSString *imageUrl = [self stringFromObject:dict[@"photo"][@"url"]];
            if (completion) {
                completion(recipe, serverId, imageUrl, nil);
            }
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        DLog(@"** error: %@ (%@), HTTPBody = %@", [error localizedDescription], operation.request.URL, [[NSString alloc] initWithData:operation.request.HTTPBody encoding:NSUTF8StringEncoding]);
        if (completion) {
            completion(recipe, 0, nil, error);
        }
    }];
}

- (void)updateRecipe:(Recipe*)recipe withCompletion:(void (^)(Recipe *recipe, NSError *error))completion {
    NSDictionary *params = @{@"recipe": @{@"name": recipe.name, @"difficulty": recipe.difficulty}};
    [self.manager PUT:[NSString stringWithFormat:@"/recipes/%d", [recipe.serverId integerValue]] parameters:params success:^(AFHTTPRequestOperation *operation, id responseObject) {
        if (completion) {
            completion(recipe, nil);
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        DLog(@"** error: %@ (%@), HTTPBody = %@", [error localizedDescription], operation.request.URL, [[NSString alloc] initWithData:operation.request.HTTPBody encoding:NSUTF8StringEncoding]);
        if (completion) {
            completion(recipe, error);
        }
    }];
}

- (void)deleteRecipe:(Recipe*)recipe withCompletionHandler:(void (^)(Recipe *recipe, NSError *error))completion {
    [self.manager DELETE:[NSString stringWithFormat:@"/recipes/%d", [recipe.serverId integerValue]] parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) {
        if (completion) {
            completion(recipe, nil);
        }
    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
        if (completion) {
            completion(recipe, error);
        }
    }];
}

#pragma mark - Managed object context sync

- (void)backgroundThreadDidSave:(NSNotification*)notification {
    // merge changes made in the background thread's context into main thread's context
    [((AppDelegate*)[UIApplication sharedApplication].delegate).managedObjectContext mergeChangesFromContextDidSaveNotification:notification];
}

#pragma mark - Other methods

- (NSString*)stringFromObject:(id)object {
    return ([object isKindOfClass:[NSString class]] ? (NSString*)object : @"");
}

- (NSNumber*)numberFromObject:(id)object {
    return ([object isKindOfClass:[NSNumber class]] ? (NSNumber*)object : ([object isKindOfClass:[NSString class]] ? @([((NSString*)object) integerValue]) : @(0)));
}

@end
